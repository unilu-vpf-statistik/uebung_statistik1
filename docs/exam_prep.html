<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Gidon Frischkorn">

<title>Übungsfragen: Klausurvorebeiteung – Übungen - VL: Statistik I</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-960cc9eac5395d1658253b679c30d018.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar docked nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Übungen - VL: Statistik I</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Übungen</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./Formelsammlung.html"> 
<span class="menu-text">Formelsammlung</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./Tabellen.html"> 
<span class="menu-text">Verteilungstabellen</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">Hilfe &amp; Kontakt</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item">Übungsfragen: Klausurvorebeiteung</li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./exercise1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Übung 1</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./exercise2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Übung 2</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./exercise3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Übung 3</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./exercise4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Übung 4</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./exercise5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Übung 5</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./exercise6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Übung 6</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./exercise7.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Übung 7</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./exercise8.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Übung 8</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./exercise9.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Übung 9</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./exercise10.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Übung 10</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./exercise11.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Übung 11</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#übungsfragen-klausur" id="toc-übungsfragen-klausur" class="nav-link active" data-scroll-target="#übungsfragen-klausur">Übungsfragen: Klausur</a>
  <ul class="collapse">
  <li><a href="#skalenniveaus" id="toc-skalenniveaus" class="nav-link" data-scroll-target="#skalenniveaus">Skalenniveaus</a></li>
  <li><a href="#masse-der-zentralen-tendenz" id="toc-masse-der-zentralen-tendenz" class="nav-link" data-scroll-target="#masse-der-zentralen-tendenz">Masse der zentralen Tendenz</a></li>
  <li><a href="#dispersionsmasse" id="toc-dispersionsmasse" class="nav-link" data-scroll-target="#dispersionsmasse">Dispersionsmasse</a></li>
  <li><a href="#wahrscheinlichkeitstheorie" id="toc-wahrscheinlichkeitstheorie" class="nav-link" data-scroll-target="#wahrscheinlichkeitstheorie">Wahrscheinlichkeitstheorie</a></li>
  <li><a href="#wahrscheinlichkeitsverteilungen" id="toc-wahrscheinlichkeitsverteilungen" class="nav-link" data-scroll-target="#wahrscheinlichkeitsverteilungen">Wahrscheinlichkeitsverteilungen</a></li>
  <li><a href="#hypothesentests" id="toc-hypothesentests" class="nav-link" data-scroll-target="#hypothesentests">Hypothesentests</a></li>
  <li><a href="#parameterschätzung" id="toc-parameterschätzung" class="nav-link" data-scroll-target="#parameterschätzung">Parameterschätzung</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Übungsfragen: Klausurvorebeiteung</h1>
<p class="subtitle lead">HS 2025</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Gidon Frischkorn </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="übungsfragen-klausur" class="level2">
<h2 class="anchored" data-anchor-id="übungsfragen-klausur">Übungsfragen: Klausur</h2>
<p>Auf dieser Übungsseite finden Sie noch weitere Übungsfragen zur Vorbereitung auf die Klausur. Die Fragen werden alle entweder Single-Choice oder K-Prim Fragen mit je 4 Antwortoptionen sein. Die Formatierung der Fragen ist nicht identisch mit der Klausur, das Frageformat ist jedoch identisch. Die Lösungen erklären die korrekten Antworten kurz, wiederholen aber nicht alle Details der jeweiligen Inhalte.</p>
<p><strong>Wichtig</strong>: Die Inhalte der Fragen sind nicht repräsentativ für die Inhalte die eventuell in der Prüfung abgefragt werden. Die Fragen sollen Ihnen ermöglichen einen guten Eindruck zu bekommen wie unterschiedliche Inhalte der Vorlesung in der Prüfung abgefragt werden.</p>
<section id="skalenniveaus" class="level3">
<h3 class="anchored" data-anchor-id="skalenniveaus">Skalenniveaus</h3>
<div class="webex-question">
<div class="webex-check webex-box">
<p>In einer Studie bewerten Teilnehmer die Stimmung einer Person auf einem Foto auf einer Skala von 1 (“sehr schlecht”) bis 7 (“sehr gut”). Welche der folgenden Aussagen beschreibt das Skalenniveau dieser Messung am treffendsten?</p>
<div id="webex-e02f983b9aaf94a7dd8f9e8135f6bf48" class="webex-radiogroup" data-answer="PgAeVxUIH1Jk">
<label><input type="radio" autocomplete="off" name="e02f983b9aaf94a7dd8f9e8135f6bf48"><span>Nominalskala, da Stimmung ein qualitatives Merkmal</span></label><label><input type="radio" autocomplete="off" name="e02f983b9aaf94a7dd8f9e8135f6bf48"><span>Ordinalskala, da die Reihenfolge der Bewertungen interpretierbar ist.</span></label><label><input type="radio" autocomplete="off" name="e02f983b9aaf94a7dd8f9e8135f6bf48"><span>Intervallskala, da die Abstände zwischen den Bewertungen psychologisch gleich gross sind</span></label><label><input type="radio" autocomplete="off" name="e02f983b9aaf94a7dd8f9e8135f6bf48"><span>Verhältnisskala, da ein absoluter Nullpunkt existiert.</span></label>
</div>
</div>
<div class="webex-solution">
<p>Die richtige Antwort ist: “<strong>Ordinalskala, da die Reihenfolge der Bewertungen interpretierbar ist.</strong>”</p>
<p>Die Messung erlaub eine Ordnung der Stimmung (“besser” vs.&nbsp;“schlechter”), aber es ist nicht garantiert, dass die Teilnehmer gleiche Abstände zwischen den einzelnen Ratingstufen annehmen. Entsprechen solltend die Werte eher auf Ordinalskalenniveau interpretiert werden, auch wenn Zahlen für die Ratings verwendet werden.</p>
<p>In der Praxis werden häufig mehrere Items solcher Rating-Skalen aggregiert. Die Summe dieser Werte bzw. der Mittelwert über mehrere solcher Items wird dann in der Regel mit einer Intervallskala interpretiert. Aus einer Methodischen Perspektive sollte dabei jedoch mit geeigneten Analysen (die wir nicht behandelt haben) getestet werden, ob diese Annahme gerechtfertigt ist.</p>
</div>
</div>
<div class="webex-question">
<div class="webex-check webex-box">
<p>Welche der folgenden Transformationen erhalten das Skalenniveau einer ordinalskalierten Variablen (z. Bsp. Rangplätze bei einem Wettrennen)?</p>
<p>Kreuzen Sie für jeden Antwort an, ob diese richtig (ankreuzen) oder falsch (nicht ankreuzen) ist.</p>
<div id="webex-51fa17c7a8ebdd645005637ed74722bd" class="webex-checkboxgroup" data-answer="bgFKUB0HTwY8">
<label><input type="checkbox" autocomplete="off" name="51fa17c7a8ebdd645005637ed74722bd"><span>Eine beliebige eineindeutige Transformation.</span></label><label><input type="checkbox" autocomplete="off" name="51fa17c7a8ebdd645005637ed74722bd"><span>Eine positive-lineare Transformation; z. Bsp. <span class="math inline">\(x' = 2x + 4\)</span></span></label><label><input type="checkbox" autocomplete="off" name="51fa17c7a8ebdd645005637ed74722bd"><span>Eine Transformation, die die Rangordnung verändert</span></label><label><input type="checkbox" autocomplete="off" name="51fa17c7a8ebdd645005637ed74722bd"><span>Eine monotone Transformation; z. Bsp. <span class="math inline">\(x' = log(x)\)</span></span></label>
</div>
</div>
<div class="webex-solution">
<p>Für eine ordinalskalierte Variable müssen Transformationen mindestens streng monoton sein. Das heisst die Funktion der Transformation steigt entweder über den gesamten Werte bereich an, oder sie fällt ab. Wenn Sie abfällt, dann würde sich bei der Transformation die Richtung der Rangfolge jeweils umdrehen.</p>
<p>Entsprechend erhalten <strong>monotone Transformationen</strong> und <strong>positiv-lineare Transformationen</strong> das Ordinalskalenniveau. Zweiteres ist eine strengere Transformation die sogar das Intervallskalenniveau erhalten würde. Diese Transformationen dürfen aber auch für niedrigere Skalenniveaus angewendet werden.</p>
<p>Eineindeutige Transformationen erhalten nur das Nominalskalenniveau, aber reichen nicht aus um das Ordinalskalenniveau zu erhalten. Und Transformationen, die die Rangordnung verändern würden die Oridale Rangfolge auch nicht erhalten.</p>
</div>
</div>
<div class="webex-question">
<div class="webex-check webex-box">
<p>Welche der folgenden Aussagen zu unterschiedlichen Datenformaten in der Programmiersprache R sind korrekt.</p>
<p>Kreuzen Sie für jeden Antwort an, ob diese richtig (ankreuzen) oder falsch (nicht ankreuzen) ist.</p>
<div id="webex-c1f58c388afcf6558a24443244d00897" class="webex-checkboxgroup" data-answer="OABKBRRSHwhl">
<label><input type="checkbox" autocomplete="off" name="c1f58c388afcf6558a24443244d00897"><span>Eine Variable vom Typ <code>factor</code> speichert kategoriale Informationen. Intern kann diese numerisch kodiert sein, ohne dass diese Zahlen eine quantitative Bedeutung haben.</span></label><label><input type="checkbox" autocomplete="off" name="c1f58c388afcf6558a24443244d00897"><span>Eine Variable vom Typ <code>vector</code> kann gleichzeitig mehrere Werte vom Typ <code>numeric</code>, <code>integer</code> oder <code>boolean</code> speichern, ohne das die unterschiedlichen Typen vorher umgewandelt werden müssen.</span></label><label><input type="checkbox" autocomplete="off" name="c1f58c388afcf6558a24443244d00897"><span>Eine Variable vom Typ <code>matrix</code> kann gleichezeitig mehrere Werte nur eines Variablentyps speichern und hat 2-Dimensionen, Zeilen &amp; Spalten.</span></label><label><input type="checkbox" autocomplete="off" name="c1f58c388afcf6558a24443244d00897"><span>Eine Variable vom Typ <code>boolean</code> kann sinnvoll verwendet werden, um beliebige ordinalskalierte Merkmale zu kodieren.</span></label>
</div>
</div>
<div class="webex-solution">
<p>Eine Variable vom Typ <code>factor</code> dient der Repräsentation kategorialer Variablen; die interne numerische Codierung ist rein technisch und nicht inhaltlich interpretierbar.</p>
<p>Eine Variable vom Typ <code>vector</code> muss homogen sein; Wenn man versucht unterschiedliche Variablentypen in dem gleichen Vektor zu speichert führt das zu einer impliziter Typkonversion (z.B. alle Werte werden zu <code>numeric</code> oder <code>character</code> konvertiert).</p>
<p>Eine Variable vom Typ <code>matrix</code> ist eine 2-dimensionale Datenstruktur dim-Attribut und kann so wie ein <code>vector</code> nur einen Datentyp enthalten.</p>
<p>Eine Variable vom Typ <code>boolean</code> kodiert logische Werte und erlaubt entsprechen nur zwei Ausprägungen (TRUE/FALSE). Daher kann eine solche Variable keine Ordnung mit mehr als zwei Stufen abbilden; Häufig erfordern ordinalskalierte Merkmale jedoch Ranginformation über mehrere Kategorien.</p>
</div>
</div>
</section>
<section id="masse-der-zentralen-tendenz" class="level3">
<h3 class="anchored" data-anchor-id="masse-der-zentralen-tendenz">Masse der zentralen Tendenz</h3>
<div class="webex-question">
<div class="webex-check webex-box">
<p>Das Alter von Frauen und Männern unter den Psychologiestudierenden im 1. Semester an der Uni Luzern hat für Frauen und Männern den Median von 22.5 und einen Mittelwert von 22.5.</p>
<p>Welche der folgenden Aussagen lässt sich aus diesen Werten zwingend ableiten? Beurteilen Sie für jede Aussage an, ob diese richtig (ankreuzen) oder falsch (nicht ankreuzen) ist.</p>
<div id="webex-667e0fafd96a6df03175404842f2388f" class="webex-checkboxgroup" data-answer="bQYbVRxXTVc5">
<label><input type="checkbox" autocomplete="off" name="667e0fafd96a6df03175404842f2388f"><span>Die Altersverteilung der Frauen und Männer sind identisch.</span></label><label><input type="checkbox" autocomplete="off" name="667e0fafd96a6df03175404842f2388f"><span>Die Streuung des Alters für Frauen und Männer ist gleich</span></label><label><input type="checkbox" autocomplete="off" name="667e0fafd96a6df03175404842f2388f"><span>Die Lage der Altersverteilung ist im Bezug auf die zentrale Tendenz gleich.</span></label><label><input type="checkbox" autocomplete="off" name="667e0fafd96a6df03175404842f2388f"><span>Die Altersverteilungden von Frauen und Männern sind symmetrisch.</span></label>
</div>
</div>
<div class="webex-solution">
<p>Richtig sind Antworten 3 und 4. Der Median und Mittelwert ist für das Alter von Frauen und Männer identisch und somit sind die Altersverteilungen zumindest in Bezug auf die zentrale Tendenz gleich. Wir haben jedoch keine Information über die Streuung, weshalb wir Antworten 1 und 2 nicht eindeutig ableiten können. Zudem sind Median und Mittelwert identisch, daraus lässt sich ableiten, dass die Altersverteilungen symmetrisch sein müssen.</p>
</div>
</div>
<div class="webex-question">
<div class="webex-check webex-box">
<p>In einer Untersuchung erheben Sie die Anzahl an korrekt gelöster Aufgaben in einem Konzentrationstest. Die Verteilung der Werte ist stark rechtsschief, da einige wenige Personen extrem viele Aufgaben lösen.</p>
<p>Welches Mass der zentralen Tendenz ist hier am sinnvollsten, um eine “typische” Leistung zu beschreiben?</p>
<div id="webex-8dedb1621a25b821fa796fecedf31edb" class="webex-radiogroup" data-answer="Y1RJVU4BGgJs">
<label><input type="radio" autocomplete="off" name="8dedb1621a25b821fa796fecedf31edb"><span>Der Modus, da dieser für Variablen jedes Skalenniveaus bestimmt werden kann.</span></label><label><input type="radio" autocomplete="off" name="8dedb1621a25b821fa796fecedf31edb"><span>Der Median, da dieser robust gegeüber Extremwerten ist</span></label><label><input type="radio" autocomplete="off" name="8dedb1621a25b821fa796fecedf31edb"><span>Der Mittelwert, da er alle Werte berücksichtigt</span></label><label><input type="radio" autocomplete="off" name="8dedb1621a25b821fa796fecedf31edb"><span>Der Mittelwert, ohne berücksichtigung der oberen 20% der Werte</span></label>
</div>
</div>
<div class="webex-solution">
<p>Für dieses Szenario ist der Median die sinnvollste Wahl um die “typische” Leistung zu beschreiben, da dieser - im Gegensatz zum Mittelwert - kaum durch die extremen Leistung einiger weniger Personen beeinflusst wird.</p>
<p>Das Filter (d.h. nicht berücksichtigen einiger Werte) ist in der Regel subjektiv, da der Cut Off ab dem Werte nicht berrücksichtig werden in der Regel nicht objektiv bestimmt werden kann.</p>
</div>
</div>
<div class="webex-question">
<div class="webex-check webex-box">
<p>Beurteilen Sie die folgenden Aussgane zur Indizierung und Auswahl von Werten aus einer Variable in R.</p>
<p>Beurteilen Sie für jede Aussage an, ob diese richtig (ankreuzen) oder falsch (nicht ankreuzen) ist.</p>
<div id="webex-6cf17b23c7c3e63ebc61b3b96809db61" class="webex-checkboxgroup" data-answer="bVJKABtSHgI+">
<label><input type="checkbox" autocomplete="off" name="6cf17b23c7c3e63ebc61b3b96809db61"><span>Für eine Variable <code>V</code> vom Typ <code>vector</code> können Werte (z. Bsp. den dritten Wert) mit Hilfe von eckigen Klammern nach dem Variablennamen ausgewählt werden: <code>V[3]</code></span></label><label><input type="checkbox" autocomplete="off" name="6cf17b23c7c3e63ebc61b3b96809db61"><span>Der <code>$</code>-Operator kann verwendet werden, um Elemente aus Listen oder Spalten aus Data Frames auszuwählen, sofern diese benannt sind.</span></label><label><input type="checkbox" autocomplete="off" name="6cf17b23c7c3e63ebc61b3b96809db61"><span>Die zweidimensionale Indizierung mit eckigen Klammern <code>[Zeile, Spalte]</code> ist nur für Variablen vom Typ <code>matrix</code> sinnvoll, nicht jedoch für Variablen des Typs <code>data.frame</code></span></label><label><input type="checkbox" autocomplete="off" name="6cf17b23c7c3e63ebc61b3b96809db61"><span>Für eine Variable <code>M</code> vom Typ <code>matrix</code> erhalte ich mit der Indizierung <code>M[2,]</code> einen Vektor der alle Werte der zweiten Zeile der Matrix enthält.</span></label>
</div>
</div>
<div class="webex-solution">
<p>Vektoren sind eindimensionale Datenstrukturen, entsprechend werden einzelne Elemente über eckige Klammern und ihre Position ausgewählt -&gt; Antwort 1 ist richtig</p>
<p>Der <code>$</code>-Operator greift auf benannte Komponenten von Listen und Data Frames zu, sofern diese benannte Elemente besitzen -&gt; Antwort 2 ist richtig</p>
<p>Auch Data Frames unterstützen eine zweidimensionale Indizierung mit <code>[Zeile, Spalte]</code>. Intern werde Data Frames von R zwar als Listen gespeichert, bei der Auswahl von Zeilen und Spalten verhalten sie sich aber matrix-ähnlich. -&gt; Antwort 3 ist also falsch</p>
<p>Bei Matrizen gibt die Auswahl einer einzelnen Zeile ohne zusätzliche Optionen standardmäßig einen Vektor zurück, der alle Spaltenwerte dieser Zeile enthält. -&gt; Antwort 4 ist richtig</p>
</div>
</div>
</section>
<section id="dispersionsmasse" class="level3">
<h3 class="anchored" data-anchor-id="dispersionsmasse">Dispersionsmasse</h3>
<div class="webex-question">
<div class="webex-check webex-box">
<p>In einer Stichprobe wurden die folgenden Werte einer intervallskalierten Variable erhoben:</p>
<p><span class="math display">\[
X={4,6,8,10}
\]</span></p>
<p>Berechnen Sie den Populationsschätzer der Standardabweichung für die Variable X.</p>
<div id="webex-b4317aa9152652306beb789861771f93" class="webex-radiogroup" data-answer="OQQfABtRTQls">
<label><input type="radio" autocomplete="off" name="b4317aa9152652306beb789861771f93"><span><span class="math inline">\(\hat{\sigma}_X = 3.00\)</span></span></label><label><input type="radio" autocomplete="off" name="b4317aa9152652306beb789861771f93"><span><span class="math inline">\(\hat{\sigma}_X = 2.58\)</span></span></label><label><input type="radio" autocomplete="off" name="b4317aa9152652306beb789861771f93"><span><span class="math inline">\(\hat{\sigma}_X = 1.74\)</span></span></label><label><input type="radio" autocomplete="off" name="b4317aa9152652306beb789861771f93"><span><span class="math inline">\(\hat{\sigma}_X = 2.00\)</span></span></label>
</div>
</div>
<div class="webex-solution">
<p>Für die Berechnung des Populationsschätzers der Variable X müssen wir als erstes den Mittelwert berechnen:</p>
<p><span class="math display">\[
\bar{X}= \frac{\sum X_i}{N} = \frac{4 + 6 + 8 + 10}{4} = 7
\]</span></p>
<p>Dann können wir die Summe der Quadrierten Abweichungen berechnen, die im Zähler der Formel für den Populationsschätzer der Standardabweichung stehen:</p>
<p><span class="math display">\[
\sum_{i =1}^N (X_i - \bar{X})^2 = (4-7)^2 + (6-7)^2 + (8-7)^2 + (10-7)^2 = 20
\]</span></p>
<p>Die Summe der Quadrierten Abweichungen teilen wir nun durch die Stichprobengrösse minus 1 (N-1) um den Populationsschätzer der Varianz zu erhalten:</p>
<p><span class="math display">\[
\hat{\sigma}^2 = \frac{\sum_{i =1}^N (X_i - \bar{X})^2}{N-1} = \frac{20}{4-1} = 6.666... \approx 6.667
\]</span></p>
<p>Und als letztes müssen wir aus dem Populationsschätzer der Varianz noch die Wurzel ziehen um den Populationsschätzer der Standardabweichung zu erhalten:</p>
<p><span class="math display">\[
\hat{\sigma} = \sqrt{\hat{\sigma}^2} = \sqrt{6.667} = 2.5820... \approx 2.58
\]</span></p>
</div>
</div>
<div class="webex-question">
<div class="webex-check webex-box">
<p>Welche der folgenden Aussagen zur Interpretation von Streuungsmassen sind korrekt?</p>
<p>Beurteilen Sie für jede Aussage an, ob diese richtig (ankreuzen) oder falsch (nicht ankreuzen) ist.</p>
<div id="webex-7763f7eb53c122fa53065623b978ccc4" class="webex-checkboxgroup" data-answer="bAcaAkoGSVJo">
<label><input type="checkbox" autocomplete="off" name="7763f7eb53c122fa53065623b978ccc4"><span>Ein größeres Streuungsmass bedeutet immer eine ungenaue Messung.</span></label><label><input type="checkbox" autocomplete="off" name="7763f7eb53c122fa53065623b978ccc4"><span>Streuungsmasse werden sinnvollerweise im Zusammenspiel mit einem Lagemass interpretiert.</span></label><label><input type="checkbox" autocomplete="off" name="7763f7eb53c122fa53065623b978ccc4"><span>Zwei Variablen mit identischem Mittelwert können sich in ihrer Streuung unterscheiden.</span></label><label><input type="checkbox" autocomplete="off" name="7763f7eb53c122fa53065623b978ccc4"><span>Die Standardabweichung von zwei Unterschiedlichen Variablen (z. Bsp. Alter und Gewicht) können gut miteinander verglichen werden.</span></label>
</div>
</div>
<div class="webex-solution">
<p>Aussage 1 ist falsch: Ein großes Streuungsmass beschreibt zunächst nur, dass sich die beobachteten Werte stärker voneinander unterscheiden. Dies kann unterschiedliche Ursachen haben, z.B.: echte Unterschiede zwischen Personen, eine heterogene Stichprobe, oder tatsächlich eine ungenaue Messung. Aus der Streuung allein lässt sich daher nicht eindeutig auf Messgenauigkeit schließen.</p>
<p>Aussage 2 ist richtig: Streuungsmasse geben an, wie stark die Werte um einen typischen Wert variieren, nicht aber, wo dieser typische Wert liegt. Erst zusammen mit einem Lagemass (z.B. Mittelwert oder Median) wird die Verteilung der Daten sinnvoll interpretierbar.</p>
<p>Aussage 3 ist richtig: Der Mittelwert beschreibt nur die zentrale Lage der Daten. Unterschiedliche Verteilungen können denselben Mittelwert haben, sich aber stark darin unterscheiden, wie breit oder eng die Werte um diesen Mittelwert verteilt sind.</p>
<p>Aussage 4 ist falsch: Die Standardabweichung wird in den Einheiten der jeweiligen Variable gemessen. Unterschiedliche Variablen (z.B. Jahre vs.&nbsp;Kilogramm) haben daher Standardabweichungen auf nicht vergleichbaren Skalen, sodass ein direkter Vergleich inhaltlich nicht sinnvoll ist.</p>
</div>
</div>
<div class="webex-question">
<div class="webex-check webex-box">
<p>Beurteilen Sie die folgenden Aussagen zur Verwendung von relationalen und logischen Operatoren in R.</p>
<p>Beurteilen Sie für jede Aussage an, ob diese richtig (ankreuzen) oder falsch (nicht ankreuzen) ist.</p>
<div id="webex-f9a85ef6c80c4c7907af87242fd32d87" class="webex-checkboxgroup" data-answer="PQhNCRlVSgc+">
<label><input type="checkbox" autocomplete="off" name="f9a85ef6c80c4c7907af87242fd32d87"><span>Relationale Operatoren vergleichen Werte miteinander und liefern als Ergebnis logische Werte (<code>TRUE</code> oder <code>FALSE</code>).</span></label><label><input type="checkbox" autocomplete="off" name="f9a85ef6c80c4c7907af87242fd32d87"><span>Der logische Operator <code>&amp;</code> verknüpft zwei logische Ausdrücke und liefert nur dann <code>TRUE</code>, wenn beide Ausdrücke <code>TRUE</code> sind.</span></label><label><input type="checkbox" autocomplete="off" name="f9a85ef6c80c4c7907af87242fd32d87"><span>Der logische Operator <code>|</code> liefert <code>TRUE</code>, wenn mindestens einer der verknüpften logischen Ausdrücke <code>FALSE</code> ist.</span></label><label><input type="checkbox" autocomplete="off" name="f9a85ef6c80c4c7907af87242fd32d87"><span>Logische Operatoren können in R auf Vektoren angewendet werden, wobei die Auswertung standardmäßig elementweise erfolgt.</span></label>
</div>
</div>
<div class="webex-solution">
<p>Aussage 1 ist richtig: Relationale Operatoren wie <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code> oder <code>!=</code> prüfen Vergleiche zwischen Werten. Das Ergebnis eines solchen Vergleichs ist immer ein logischer Wert, der angibt, ob die jeweilige Bedingung erfüllt ist.</p>
<p>Aussage 2 ist richtig: Der Operator <code>&amp;</code> entspricht einer logischen UND-Verknüpfung. Nur wenn beide verknüpften logischen Ausdrücke den Wert <code>TRUE</code> haben, ist auch das Gesamtergebnis <code>TRUE</code>.</p>
<p>Aussage 3 ist falsch: Der Operator <code>|</code> steht für eine logische ODER-Verknüpfung. Er liefert <code>TRUE</code>, wenn mindestens einer der verknüpften logischen Ausdrücke <code>TRUE</code> ist – nicht <code>FALSE</code>.</p>
<p>Aussage 4 ist richtig: In R werden logische Operationen auf Vektoren standardmäßig elementweise ausgewertet. Das bedeutet, dass jedes Element eines Vektors separat mit dem entsprechenden Element eines anderen Vektors verglichen oder verknüpft wird.</p>
</div>
</div>
</section>
<section id="wahrscheinlichkeitstheorie" class="level3">
<h3 class="anchored" data-anchor-id="wahrscheinlichkeitstheorie">Wahrscheinlichkeitstheorie</h3>
<div class="webex-question">
<div class="webex-check webex-box">
<p>In der psychologischen Diagnostik wird in der Regel eine Anfangseinschätzung (z.B. zur Wahrscheinlichkeit einer Störung) auf Basis neuer Informationen (z. Bsp. Symptome oder Persönlichkeitseigenschaften) angepasst. Welche der folgenden Aussagen beschreiben zutreffend die Rolle des Bayes-Theorems in diesem Prozess?</p>
<p>Beurteilen Sie für jede Aussage an, ob diese richtig (ankreuzen) oder falsch (nicht ankreuzen) ist.</p>
<div id="webex-45297a2663c06cd33e8db4c8834a08b8" class="webex-checkboxgroup" data-answer="bwQeCRtQHgdr">
<label><input type="checkbox" autocomplete="off" name="45297a2663c06cd33e8db4c8834a08b8"><span>Das Bayes-Theorem beschreibt, wie eine anfängliche Wahrscheinlichkeit durch neue Evidenz systematisch aktualisiert wird.</span></label><label><input type="checkbox" autocomplete="off" name="45297a2663c06cd33e8db4c8834a08b8"><span>Bayes-Theorem ersetzt fachliches Vorwissen durch eine rein datengetriebene Entscheidung.</span></label><label><input type="checkbox" autocomplete="off" name="45297a2663c06cd33e8db4c8834a08b8"><span>Die Relevanz neuer Information hängt davon ab, wie häufig das betrachtete Merkmal oder Ereignis in der Population vorkommt.</span></label><label><input type="checkbox" autocomplete="off" name="45297a2663c06cd33e8db4c8834a08b8"><span>Ohne Berücksichtigung der Ausgangswahrscheinlichkeit kann neue Evidenz leicht überschätzt werden.</span></label>
</div>
</div>
<div class="webex-solution">
<p>Aussage 1 ist richtig: Die zentrale Funktion des Bayes-Theorems ist die Aktualisierung von Wahrscheinlichkeiten: Eine anfängliche Einschätzung (Prior) wird durch neue Information (Evidenz / Likelihoo) angepasst und führt zu einer aktualisierten Wahrscheinlichkeit (Posterior).</p>
<p>Aussage 2 ist falsch: Das Bayes-Theorem integriert fachliches Vorwissen in Form der Anfangswahrscheinlichkeit mit neuen Daten. Es ersetzt Vorwissen also nicht, sondern macht dessen Einfluss transparent und formalisierbar.</p>
<p>Aussage 3 ist richtig: Die Häufigkeit eines Merkmals in der Population (Basisrate) beeinflusst, wie stark neue Evidenz die Einschätzung verändern kann. Seltene Ereignisse bleiben selbst bei scheinbar starker Evidenz (hohe Sensitivität und Spezifität) oft unwahrscheinlich.</p>
<p>Aussage 4 ist richtig: Wenn Basisraten ignoriert werden, wird die diagnostische Aussagekraft neuer Information häufig überschätzt. Dieses Phänomen ist als Basisratenfehler bekannt und ein zentrales Anwendungsargument für das Bayes-Theorem.</p>
</div>
</div>
<div class="webex-question">
<div class="webex-check webex-box">
<p>In einer psychologischen Studie nehmen 20 Versuchspersonen teil. Für eine aufwendige Zusatzaufgabe werden 3 Personen zufällig ausgewählt. Sie nehmen selbst an der Studie teil und hoffen, nicht ausgewählt zu werden. Beurteilen Sie die folgenden Aussagen.</p>
<p>Kreuzen Sie bei jeder Aussage an, ob sie richtig oder falsch ist.</p>
<div id="webex-0951c95cba84e5b322bb1b2617e351b4" class="webex-checkboxgroup" data-answer="awgZAE8IGVM/">
<label><input type="checkbox" autocomplete="off" name="0951c95cba84e5b322bb1b2617e351b4"><span>Für dieses Zufallsexperiment ist ein kombinatorisches Modell ohne Zurücklegen und ohne Berücksichtigung der Reihenfolge angemessen.</span></label><label><input type="checkbox" autocomplete="off" name="0951c95cba84e5b322bb1b2617e351b4"><span>Die Gesamtzahl möglicher Kombinationen an Personen die für das Zufallsexperiment ausgewählt werden lässt sich mit dem Binomialkoeffizienten <span class="math inline">\(\binom{20}{3}\)</span> berechnen.</span></label><label><input type="checkbox" autocomplete="off" name="0951c95cba84e5b322bb1b2617e351b4"><span>Haben bereits 10 Personen teilgenommen, wobei 2 Personen bereits für die Zusatzaufgabe ausgewählt wurden, so beträgt die Wahrscheinlichkeit, dass Sie noch ausgewählt werden <span class="math inline">\(\frac{1}{10}\)</span>.</span></label><label><input type="checkbox" autocomplete="off" name="0951c95cba84e5b322bb1b2617e351b4"><span>Die Wahrscheinlichkeit, dass sie nicht ausgewählt werden liegt bei 0.90</span></label>
</div>
</div>
<div class="webex-solution">
<p>Aussage 1 ist richtig: Jede Versuchsperson kann höchstens einmal für die Zusatzaufgabe ausgewählt werden (ohne Zurücklegen). Für die Frage, welche drei Personen ausgewählt werden, spielt die Reihenfolge der Auswahl keine Rolle (ohne Berücksichtigung der Reihenfolge).</p>
<p>Aussage 2 ist richtig: Es werden drei Personen aus insgesamt 20 ausgewählt, ohne Zurücklegen und ohne Reihenfolge. Genau dieses Szenario wird durch den Binomialkoeffizienten <span class="math inline">\(\binom{20}{3}\)</span> beschrieben.</p>
<p>Aussage 3 ist richtig: Insgesamt sollen drei Personen ausgewählt werden. Wenn bereits zwei Personen ausgewählt wurden, bleibt ein Platz für die Zusatzaufgabe. Sind noch 10 Personen im Pool, ist die Wahrscheinlichkeit, dass dieser letzte Platz auf Sie fällt <span class="math inline">\(\frac{1}{10}\)</span></p>
<p>Aussage 4 ist falsch: Die Wahrscheinlichkeit nicht ausgewählt zu werden berechnet sich als LaPlace Wahrscheinlichkeit <span class="math inline">\(P(A) = \frac{N_A}{K}\)</span>aus der Gesamtzahl möglicher Personenkombinationen die aus der Gesamtstichprobe ausgewählt werden können: <span class="math inline">\(K = \binom{20}{3}\)</span>, während die Anzahl für Sie günstiger Ereignisse <span class="math inline">\(N_A\)</span> sich aus der Gesamtzahl an Personenkombinationen berechnet, wenn die Personen aus den anderen 19 Teilnehmern am Experiment gezogen werden: <span class="math inline">\(N_A = \binom{19}{3}\)</span>. Entsprechend gilt:</p>
<p><span class="math display">\[
P(A) = \frac{N_A}{K} = \frac{\binom{19}{3}}{\binom{20}{3}} = \frac{969}{1140} = 0.85
\]</span></p>
</div>
</div>
</section>
<section id="wahrscheinlichkeitsverteilungen" class="level3">
<h3 class="anchored" data-anchor-id="wahrscheinlichkeitsverteilungen">Wahrscheinlichkeitsverteilungen</h3>
<div class="webex-question">
<div class="webex-check webex-box">
<p>In einer Aufmerksamkeitsaufgabe muss eine Versuchsperson bei jedem Durchgang entscheiden, ob ein Zielreiz präsentiert wurde oder nicht. Die Wahrscheinlichkeit für eine korrekte Entscheidung bei reinem Raten beträgt <span class="math inline">\(p = 0.5\)</span>. Die Aufgabe wird 4-mal durchgeführt.</p>
<p>Wie groß ist die Wahrscheinlichkeit, dass die Versuchsperson die rät genau 2 richtige Entscheidungen trifft?</p>
<div id="webex-8fa553075b0abc7007a5352cd9423c4f" class="webex-radiogroup" data-answer="Y1ZNBRkCHAdo">
<label><input type="radio" autocomplete="off" name="8fa553075b0abc7007a5352cd9423c4f"><span><span class="math inline">\(P(X = 2) = 0.125\)</span></span></label><label><input type="radio" autocomplete="off" name="8fa553075b0abc7007a5352cd9423c4f"><span><span class="math inline">\(P(X = 2) = 0.250\)</span></span></label><label><input type="radio" autocomplete="off" name="8fa553075b0abc7007a5352cd9423c4f"><span><span class="math inline">\(P(X = 2) = 0.375\)</span></span></label><label><input type="radio" autocomplete="off" name="8fa553075b0abc7007a5352cd9423c4f"><span><span class="math inline">\(P(X = 2) = 0.500\)</span></span></label>
</div>
</div>
<div class="webex-solution">
<p>Gesucht ist die Wahrscheinlichkeit, dass eine Versuchsperson bei 4 unabhängigen Durchgängen einer Aufmerksamkeitsaufgabe genau 2 richtige Entscheidungen trifft, wenn die Erfolgswahrscheinlichkeit pro Durchgang bei <span class="math inline">\(p = 0.5\)</span> liegt.</p>
<p>Für die Berechnung dieser Wahrscheinlichkeit können wir die Binomialverteilung nutzen. Dabei müssen wir die entsprechenden Werte in die Wahrscheinlichkeitsfunktion der Binomialverteilung einsetzen:</p>
<p><span class="math display">\[
P(X = 2) = \binom{4}{2} \cdot 0.5^2 \cdot (1-0.5)^{4-2} = 6 \cdot 0.25 \cdot 0.25 = 0.375
\]</span></p>
</div>
</div>
<div class="webex-question">
<div class="webex-check webex-box">
<p>Beurteilen Sie die folgenden Aussagen zu diskreten und kontinuierlichen Wahrscheinlichkeitsverteilungen.</p>
<p>Kreuzen Sie bei jeder Aussage an, ob sie richtig oder falsch ist.</p>
<div id="webex-85dccc78425455b2b22a46e9926e742e" class="webex-checkboxgroup" data-answer="YwRIU09SGwlp">
<label><input type="checkbox" autocomplete="off" name="85dccc78425455b2b22a46e9926e742e"><span>Bei diskreten Zufallsvariablen kann einzelnen Ausprägungen eine positive Wahrscheinlichkeit zugeordnet werden.</span></label><label><input type="checkbox" autocomplete="off" name="85dccc78425455b2b22a46e9926e742e"><span>Bei kontinuierlichen Zufallsvariablen ist die Wahrscheinlichkeit für einen einzelnen, exakt bestimmten Wert größer als null.</span></label><label><input type="checkbox" autocomplete="off" name="85dccc78425455b2b22a46e9926e742e"><span>Wahrscheinlichkeitsverteilungen beschreiben, wie wahrscheinlich unterschiedliche Ausprägungen einer Zufallsvariablen sind.</span></label><label><input type="checkbox" autocomplete="off" name="85dccc78425455b2b22a46e9926e742e"><span>Die Verteilungsfunktion gibt an, wie groß die Wahrscheinlichkeit ist, dass eine Zufallsvariable einen Wert kleiner oder gleich einem bestimmten Wert annimmt.</span></label>
</div>
</div>
<div class="webex-solution">
<p>Aussage 1 ist richtig: Diskrete Zufallsvariablen besitzen eine abzählbare Menge möglicher Ausprägungen.Daher kann für jeden einzelnen Wert eine konkrete, positive Wahrscheinlichkeit angegeben werden (z.B. <span class="math inline">\(P(X=3)=0.2\)</span>)</p>
<p>Aussage 2 ist richtig: Bei kontinuierlichen Zufallsvariablen ist die Wahrscheinlichkeit für einen exakt bestimmten Einzelwert immer null. Wahrscheinlichkeiten ergeben sich nur für Intervalle von Werten, nicht für einzelne Punkte.</p>
<p>Aussage 3 ist richtig: Eine Wahrscheinlichkeitsverteilung ordnet möglichen Ausprägungen einer Zufallsvariablen Wahrscheinlichkeiten zu (bei diskreten Variablen) oder beschreibt die Wahrscheinlichkeitsdichte über Wertebereiche (bei kontinuierlichen Variablen).</p>
<p>Aussage 4 ist falsch: Die Verteilungsfunktion <span class="math inline">\(F(x)\)</span> einer Wahrscheinlichkeitsfunktion <span class="math inline">\(f(x)\)</span> ist definiert als:</p>
<p><span class="math display">\[
F(x)=P(X≤x).
\]</span></p>
<p>Sie gibt die kumulierte Wahrscheinlichkeit bis zu einem bestimmten Wert an – unabhängig davon, ob die Zufallsvariable diskret oder kontinuierlich ist.</p>
</div>
</div>
<div class="webex-question">
<div class="webex-check webex-box">
<p>Beurteilen Sie die folgenden Aussagen zu den in R implementierten Funktionen der Normalverteilung (<code>dnorm</code>, <code>pnorm</code>, <code>qnorm</code>, <code>rnorm</code>).</p>
<p>Kreuzen Sie bei jeder Aussage an, ob sie richtig oder falsch ist.</p>
<div id="webex-3d151113a0881e975c0f68144eed0cf5" class="webex-checkboxgroup" data-answer="aFUdBR0AHQM8">
<label><input type="checkbox" autocomplete="off" name="3d151113a0881e975c0f68144eed0cf5"><span><code>dnorm(x, mean = 0, sd = 1)</code> liefert die Wahrscheinlichkeitsdichte an der Stelle <code>x</code> für eine Standardnormalverteilung.</span></label><label><input type="checkbox" autocomplete="off" name="3d151113a0881e975c0f68144eed0cf5"><span><code>pnorm(x = 10, mean = 5, sd = 2)</code> berechnet die Wahrscheinlichkeit, dass eine normalverteilte Zufallsvariable mit dem Mittelwert = 5 und der Varianz = 2 einen Wert kleiner oder gleich von 10 annimmt.</span></label><label><input type="checkbox" autocomplete="off" name="3d151113a0881e975c0f68144eed0cf5"><span><code>qnorm(p = .80, mean = 0, sd = 1)</code> liefert denjenigen Wert <code>x</code>, für den gilt, dass bei einer Standardnormalverteilung 80% der Werte kleiner oder gleich dem Wert <code>x</code> sind.</span></label><label><input type="checkbox" autocomplete="off" name="3d151113a0881e975c0f68144eed0cf5"><span><code>rnorm(n = 50, mean = 100, sd = 15)</code> erzeugt 50 Zufallszahlen, deren Mittelwert 100 und deren Standardabweichung 15 ist.</span></label>
</div>
</div>
<div class="webex-solution">
<p>Aussage 1 ist richtig: <code>dnorm()</code> gibt den Wert der Dichtefunktion an der Stelle x zurück. Mit den Argumenten <code>mean = 0</code> und <code>sd = 1</code> ist die zugrunde liegende Verteilung eine Standardnormalverteilung. <em>Wichtig:</em> Es handelt sich bei dem Ergebnis um eine Dichte, und nicht um eine Wahrscheinlichkeit für einen exakten Wert.</p>
<p>Aussage 2 ist falsch: <code>pnorm()</code> berechnet zwar korrekt die Wahrscheinlichkeit <span class="math inline">\(P(X≤10)\)</span> aber das Argument <code>sd = 2</code> beschreibt die Standardabweichung, nicht die Varianz. Die Varianz wäre hier <span class="math inline">\(2^2 = 4\)</span>. Die Aussage ist daher inhaltlich falsch formuliert.</p>
<p>Aussage 3 ist richtig: <code>qnorm()</code> ist die Quantilfunktion der Normalverteilung. Sie liefert genau den Wert <code>x</code>, für den die kumulierte Wahrscheinlichkeit <span class="math inline">\(P(X≤x)=0.80\)</span> gilt. Mit <code>mean = 0</code> und <code>sd = 1</code> bezieht sich dies auch auf die Standardnormalverteilung.</p>
<p>Aussage 4 ist falsch: <code>rnorm()</code> erzeugt Zufallszahlen aus einer Normalverteilung mit den angegebenen Parametern. Dabei ist der erwartete Mittelwert = 100 und die erwartete Standardabweichung = 15, aber die tatsächlich gezogene Stichprobe hat im Allgemeinen nicht exakt diese Kennwerte.</p>
</div>
</div>
</section>
<section id="hypothesentests" class="level3">
<h3 class="anchored" data-anchor-id="hypothesentests">Hypothesentests</h3>
<div class="webex-question">
<div class="webex-check webex-box">
<p>Beurteilen Sie die folgenden Aussagen zur Logik von statistischen Hypothesentests.</p>
<p>Kreuzen Sie bei jeder Aussage an, ob sie richtig oder falsch ist.</p>
<div id="webex-f0725bb309b3e05581105babc3d01137" class="webex-checkboxgroup" data-answer="PQEbAhlTTgNt">
<label><input type="checkbox" autocomplete="off" name="f0725bb309b3e05581105babc3d01137"><span>Ein statistischer Hypothesentest prüft, wie wahrscheinlich die beobachteten Daten unter Annahme der Nullhypothese sind.</span></label><label><input type="checkbox" autocomplete="off" name="f0725bb309b3e05581105babc3d01137"><span>Wird die Nullhypothese verworfen, gilt die Alternativhypothese mit Sicherheit als wahr.</span></label><label><input type="checkbox" autocomplete="off" name="f0725bb309b3e05581105babc3d01137"><span>Die Testentscheidung bezieht sich immer auf ein vor der Berechnung des Tests festgelegtes Signifikanzniveau.</span></label><label><input type="checkbox" autocomplete="off" name="f0725bb309b3e05581105babc3d01137"><span>Ein nicht signifikanter Test bedeutet, dass der Effekt in der Population gleich null ist.</span></label>
</div>
</div>
<div class="webex-solution">
<p>Aussage 1 ist richtig: Sowohl bei Hypothesentest im Sinne von Fischer (Nullhypothesentest), wie auch nach dem Binären Entscheidungskonzept wird beurteilt, wie gut die beobachteten Daten mit der Annahme der Nullhypothese vereinbar sind. Der <span class="math inline">\(p\)</span>-Wert gibt dabei an, wie wahrscheinlich die beobachteten (oder extremere) Daten wären, wenn die Nullhypothese gilt. Zusätzlichen wird bei der Anwendung des Binären Entscheidungskonzepts der Stichprobenumfang auf Basis eines angenommenen Effekts so gewählt, dass man eine vorher festgesetzte Power (<span class="math inline">\(1 - \beta\)</span>) erreicht, und so auch die Wahrscheinlichkeit fälschlicherweise die Nullhypothese anzunehmen, obwohl in der Population die Alternativhypothese gilt zu kontrollieren.</p>
<p>Aussage 2 ist falsch: Das Verwerfen der Nullhypothese bedeutet lediglich, dass die Daten unter Annahme der Nullhypothese unwahrscheinlich sind. Es liefert keinen sicheren Beweis für die Alternativhypothese.</p>
<p>Aussage 3 ist richtig: Das Signifikanzniveau <span class="math inline">\(\alpha\)</span> wird vor der Testdurchführung festgelegt und definiert die Entscheidungsregel (z. B. Verwerfen der <span class="math inline">\(H_0\)</span>, wenn <span class="math inline">\(p &lt; \alpha\)</span>. Für die Gültigkeit der Testentscheidung ms das Signifikanzniveau a-priori also vor der Testung festgelegt werden.</p>
<p>Aussage 4 ist falsch: Ein nicht signifikantes Ergebnis bedeutet lediglich, dass nicht genügend Evidenz gegen die Nullhypothese vorliegt. Es erlaubt keine Aussage, dass der Effekt in der Population tatsächlich null ist; der Effekt kann existieren, aber z. B. klein oder die Stichprobe zu klein sein.</p>
</div>
</div>
<div class="webex-question">
<div class="webex-check webex-box">
<p>Ein statistischer Test ergibt ein signifikantes Ergebnis bei <span class="math inline">\(\alpha = .05\)</span></p>
<p>Kreuzen Sie bei jeder Aussage an, ob sie richtig oder falsch ist.</p>
<div id="webex-e9ebda580ad00ab0948d98fddbba3456" class="webex-checkboxgroup" data-answer="PghJUkhRGQlt">
<label><input type="checkbox" autocomplete="off" name="e9ebda580ad00ab0948d98fddbba3456"><span>Das Ergebnis ist statistisch bedeutsam im Sinne des gewählten Signifikanzniveaus.</span></label><label><input type="checkbox" autocomplete="off" name="e9ebda580ad00ab0948d98fddbba3456"><span>Die Wahrscheinlichkeit, dass die Nullhypothese wahr ist, beträgt weniger als 5 %.</span></label><label><input type="checkbox" autocomplete="off" name="e9ebda580ad00ab0948d98fddbba3456"><span>Bei einer Wiederholung der Studie wird das Ergebnis mit Sicherheit erneut signifikant ausfallen.</span></label><label><input type="checkbox" autocomplete="off" name="e9ebda580ad00ab0948d98fddbba3456"><span>Ein signifikanter Test sagt nichts über die Größe oder praktische Relevanz des Effekts aus.</span></label>
</div>
</div>
<div class="webex-solution">
<p>Aussage 1 ist richtig: Ein signifikantes Testergebnis bei <span class="math inline">\(\alpha=.05\)</span> bedeutet, dass der berechnete p-Wert kleiner als das vorab festgelegte Signifikanzniveau ist. Damit ist das Ergebnis statistisch bedeutsam gemäß der Entscheidungsregel des Tests.</p>
<p>Aussage 2 ist falsch: Der p-Wert (und damit auch das Signifikanzniveau) beschreibt die Wahrscheinlichkeit der Daten unter Annahme der Nullhypothese, nicht die Wahrscheinlichkeit, dass die Nullhypothese wahr ist. Aussagen über die Wahrscheinlichkeit der Hypothesen selbst sind im klassischen Hypothesentesten nicht möglich.</p>
<p>Aussage 3 ist falsch: Das Ergebnis statistischer Tests sind Zufallsvariablen und damit kann ein erneuter Test auch bei identischem Studiendesign ein anderes Ergebnis liefern. Die Signifikanz eines Tests garantiert also keine Reproduzierbarkeit der Ergebnisse.</p>
<p>Aussage 4 ist richtig: Die statistische Signifikanz gibt lediglich Auskunft darüber, ob ein Effekt unter der Nullhypothese als unwahrscheinlich gilt. Sie macht keine Aussage darüber, wie groß der Effekt ist oder ob er praktisch oder inhaltlich bedeutsam ist.</p>
</div>
</div>
</section>
<section id="parameterschätzung" class="level3">
<h3 class="anchored" data-anchor-id="parameterschätzung">Parameterschätzung</h3>
<div class="webex-question">
<div class="webex-check webex-box">
<p>Beurteilen Sie die folgenden Aussagen zum Standardfehler des Mittelwertes.</p>
<p>Kreuzen Sie bei jeder Aussage an, ob sie richtig oder falsch ist.</p>
<div id="webex-84f812ff607f585b8060435c4f0b4bcf" class="webex-checkboxgroup" data-answer="YwVKCR0CSlZr">
<label><input type="checkbox" autocomplete="off" name="84f812ff607f585b8060435c4f0b4bcf"><span>Für eine Stichprobe von 50 Personen beträgt der Standardfehler des Mittelwertes <span class="math inline">\(\sigma_{\bar{x}} = 1.41\)</span>, wenn die bei einer Populationsstandardabweichung <span class="math inline">\(\sigma_x = 10\)</span> beträgt.</span></label><label><input type="checkbox" autocomplete="off" name="84f812ff607f585b8060435c4f0b4bcf"><span>Wird die Stichprobengrösse vervierfacht, so halbiert sich der Standardfehler des Mittelwertes, sofern die Streuung der Variable konstant bleibt.</span></label><label><input type="checkbox" autocomplete="off" name="84f812ff607f585b8060435c4f0b4bcf"><span>Für eine Variable <span class="math inline">\(X \sim \mathcal{N}(\mu = 10, \sigma = 2)\)</span> ist im Mittel zu erwarten, dass aus 10 unabhängigen Stichproben mit <span class="math inline">\(N = 10\)</span> etwa eine Stichprobe einen Mittelwert grösser als <span class="math inline">\(\bar{x} = 11.04\)</span> aufweist.</span></label><label><input type="checkbox" autocomplete="off" name="84f812ff607f585b8060435c4f0b4bcf"><span>Wenn der Standardfehler des Mittelwert einer Variable X <span class="math inline">\(\sigma_{\bar{x}} = 2\)</span> beträgt und die Standardabweichung der Variable X <span class="math inline">\(\sigma_x = 12\)</span> ist, dann betrug die Stichprobengrösse <span class="math inline">\(N = 64\)</span>.</span></label>
</div>
</div>
<div class="webex-solution">
<p><strong>Aussage 1</strong> ist richtig: Wenn wir den Standardfehler auf Basis der gegebene Werte berechnen, erhalten wir:</p>
<p><span class="math display">\[
\sigma_{\bar{x}}= \frac{10}{\sqrt{50}} = \frac{10}{7.071} = 1.4142... \approx 1.41
\]</span> was genau dem in der Aussage angegebenen Wert entspricht.</p>
<p><strong>Aussage 2</strong> ist richtig: Der Standardfehler ist proportional zu <span class="math inline">\(\frac{1}{\sqrt{N}}\)</span>. Wird N vervierfacht, verdoppelt sich <span class="math inline">\(\sqrt{N}\)</span> und der Standardfehler halbiert sich entsprechend. Nehmen wir an der Standardfehler bei N = 20 ist 1, dann ist der Standardfehler bei N = 80:</p>
<p><span class="math display">\[
\sigma_{\bar{x}(N = 80)} = \frac{\sigma_x}{\sqrt{N_{20} \cdot 4}} = \frac{\sigma_x}{2 \cdot \sqrt{N_{20}}} = \frac{1}{2} \cdot \sigma_{\hat{x}(N=20)}
\]</span></p>
<p><strong>Aussage 3</strong> ist falsch: Die Stichprobenmittelwerte im beschriebenen Szenario folgen einer Normalverteilung mit dem Standardfehler des Mittelwerts:</p>
<p><span class="math display">\[
\sigma_{\bar{x}} = \frac{2}{\sqrt{10}} \approx 0.632
\]</span></p>
<p>Mit Hilfe der <span class="math inline">\(z\)</span>-Standardisierung können wir den <span class="math inline">\(z\)</span>-Wert für den im Szenario genannten Mittwert von <span class="math inline">\(\bar{x} = 11.04\)</span> berechnen: <span class="math inline">\(z = \frac{11.04-10}{0.632} \approx 1.65\)</span>.</p>
<p>Anhand der Verteilungsfunktion der Standardnormalverteilung können wir bestimmend, dass für diesen Wert nur 5% der Werte eine Wahrscheinlichkeit haben grösser als dieser Wert zu sein:</p>
<p><span class="math display">\[
P (X &gt; 11.04) = 1 - P(X \leq 11.04) = 1 - P(z \leq 1.65) = 1 - .95
\]</span></p>
<p>Die Erwartete Anzahl einer Stichprobe mit einem Mittelwert <span class="math inline">\(\bar{x} \geq 11.04\)</span> bei 10 unabhängigen Stichproben ist also <span class="math inline">\(10 \cdot 0.05 = 0.5\)</span>. Es ist also nicht im Mittel eine, sondern eine halbe Stichprobe zu erwarten.</p>
<p><strong>Aussage 4</strong> ist falsch: Wenn wir aus der Formel des Standardfehlers und den gegebenen Werten die Stichprobengrösse berechnen ergibt sich:</p>
<p><span class="math display">\[
2 = \frac{12}{\sqrt{N}}; \quad \sqrt{N} = \frac{12}{2} = 6; \quad N = 6^2 = 36
\]</span></p>
<p>Die angegebene Stichprobengrösse <span class="math inline">\(N=64\)</span> ist daher falsch.</p>
</div>
</div>
<div class="webex-question">
<div class="webex-check webex-box">
<p>Beurteilen Sie die folgenden Aussagen zur Verteilung von Stichprobenkennwerten und deren Bezug zum Zentralen Grenzwerttheorem.</p>
<p>Kreuzen Sie bei jeder Aussage an, ob sie richtig oder falsch ist.</p>
<div id="webex-b282cf888b2615be5e644a147ca059dd" class="webex-checkboxgroup" data-answer="OQMUAk9XFAll">
<label><input type="checkbox" autocomplete="off" name="b282cf888b2615be5e644a147ca059dd"><span>Auch wenn die Verteilung einzelner Messwerte aus einer Population nicht normalverteilt ist, nähert sich die Verteilung des Stichprobenmittelwerts für große Stichproben einer Normalverteilung an.</span></label><label><input type="checkbox" autocomplete="off" name="b282cf888b2615be5e644a147ca059dd"><span>Das Zentrale Grenzwerttheorem besagt, dass die Verteilung der Rohdaten für grosse Stichprobe zu einer Normalverteilung konvergiert.</span></label><label><input type="checkbox" autocomplete="off" name="b282cf888b2615be5e644a147ca059dd"><span>Die Verteilung des Stichprobenmittelwerts beschreibt, wie stark der geschätzte Mittelwert von Stichprobe zu Stichprobe variiert.</span></label><label><input type="checkbox" autocomplete="off" name="b282cf888b2615be5e644a147ca059dd"><span>Die Streuung der Verteilung des Stichprobenmittelwerts ist kleiner als die Streuung der ursprünglichen Population.</span></label>
</div>
</div>
<div class="webex-solution">
<p>Aussage 1 ist richtig: Unabhängig von der Form der Populationsverteilung (vorausgesetzt, die Varianz ist endlich) wird die Verteilung des Stichprobenmittelwerts mit wachsender Stichprobengröße näherungsweise normalverteilt, das ist die Kernaussage des Zentralen Grenzwerttheorems</p>
<p>Aussage 2 ist falsch: Das Zentrale Grenzwerttheorem bezieht sich nicht auf die Verteilung der Rohdaten, sondern auf die Verteilung eines Stichprobenkennwerts (typischerweise des Mittelwerts). Die Verteilung der Rohdaten bleibt auch bei großen Stichproben so geformt wie die zugrunde liegende Populationsverteilung.</p>
<p>Aussage 3 ist richtig: Die Verteilung des Stichprobenmittelwerts beschreibt die zufallsbedingte Variation des geschätzten Mittelwerts über wiederholte Stichproben hinweg und damit die Unsicherheit der Parameterschätzung.</p>
<p>Aussage 4 ist richtig: Die Streuung der Stichprobenmittelwertsverteilung ist der Standardfehler:</p>
<p><span class="math display">\[
SE = \frac{\sigma}{\sqrt{N}}
\]</span></p>
<p>Da durch die Streuung <span class="math inline">\(\sigma\)</span> durch Wurzel der Stichprobengrösse <span class="math inline">\(N\)</span> geteilt wird ist der Standardfehler stets kleiner (oder gleich bei N = 1) als die Populationsstandardabweichung.</p>
</div>
</div>


</section>
</section>

</main> <!-- /main -->
<script>

/* definition of content for the buttons */
const webex_buttons = {check_hidden:          "<b>&check;</b>",
                       check_hidden_alt:      "Check answer",
                       check_shown:           "<b>&lsh;</b>",
                       check_shown_alt:       "Hide check",
                       check_of_total:        "/",
                       solution:              "<b>&quest;</b>",
                       solution_alt:          "Correct solution",
                       question_next:         "<b>&#8634;</b>",
                       question_next_alt:     "Next question",
                       question_previous:     "",
                       question_previous_alt: ""}


/* update total correct if #webex-total_correct exists */
update_total_correct = function() {
  console.log("webex: update total_correct");

  document.querySelectorAll(".webex-total_correct").forEach(total => {
    p = total.closest(".webex-box");
    var correct = p.getElementsByClassName("webex-correct").length;
    var solvemes = p.getElementsByClassName("webex-solveme").length;
    var radiogroups = p.getElementsByClassName("webex-radiogroup").length;
    var selects = p.getElementsByClassName("webex-select").length;
    /* no specific class on input node, thus searching via query selector */
    var checkboxgroups = p.querySelectorAll("div[class=webex-checkboxgroup] input[type=checkbox]").length

    /* show number of correct / total number of answers */
    total.innerHTML = correct + "&nbsp;" + webex_buttons.check_of_total + "&nbsp;" + (solvemes + radiogroups + checkboxgroups + selects);
  });
}

/* check answers */
check_func = function() {
  console.log("webex: check answer");

  //var cl = elem.parentElement.classList;
  var cl = this.closest(".webex-box").classList;
  if (cl.contains("unchecked")) {
    cl.remove("unchecked");
    this.innerHTML = webex_buttons.check_shown; //"Hide check";
    if (webex_buttons.check_shown_alt.length > 0) this.setAttribute("title", webex_buttons.check_shown_alt);
  } else {
    cl.add("unchecked");
    this.innerHTML = webex_buttons.check_hidden; //"Check answer";
    if (webex_buttons.check_hidden_alt.length > 0) this.setAttribute("title", webex_buttons.check_hidden_alt);
  }
}

/* helper functions for checking the webex ID */
const id_checker = {"fmt": new RegExp("[g-zG-Z]"),
                    "load": function(e) { return e.getAttribute("id").match("(?<=(-)).*$")[0]; },
                    "eval": new TextEncoder(),
                    "dval": new TextDecoder()}

/* Show/hide correct solution */
solution_func = function() {
  console.log("webex: show/hide solution");

  var div = this.closest(".webex-question").querySelector(".webex-solution");
  var cl = div.classList;

  if (cl.contains("visible")) {
    cl.remove("visible");
  } else {
    cl.add("visible");
  }
}

/* function to check if the real answer is numeric */
convert_to_numeric = function(x) {
  if (typeof x == "string") {
    /* do nothing */
  } else if (x.length == 1) {
    /* take first element */
    x = x[0]
  } else {
    return NaN;
  }

  /* remove spaces for easier parsing */
  x = x.replace(/\s/g, "");

  /* Define patterns for different formats, note that spaces have been removed above */
  const patterns = [
    {regex: /^[+-]?\d+(\.\d{3})*,\d+$/, decimal: ",", thousand: "." },  // Format: "1.100.100.100,3"
    {regex: /^[+-]?\d+(,\d{3})*\.\d+$/, decimal: ".", thousand: "," },  // Format: "1,100,100,100.3"
    {regex: /^[+-]?\d+(\.|\.\d+)?$/, decimal: "." },                    // Format: "1100100100.5" or "1100100100."
    {regex: /^[+-]?\d+(,|,\d+)$/, decimal: "," }                        // Format: "1100100100,5" or "1100100100,"
  ];


  /* testing all regular expressions, convert to float if possible */
  for (const { regex, decimal, thousand } of patterns) {
    if (regex.test(x)) {
      let numeric = x;
      if (thousand) numeric = numeric.replace(new RegExp(`\\${thousand}`, "g"), "");
      numeric = numeric.replace(decimal, ".");
      return parseFloat(numeric);
    }
  }

  /* input of length 1 but none of the known formats, return NaN */
  return NaN;
}

/* Checking webex ID, returns formalsol */
check_id = function(e) {
  /* loading webex ID */
  var id = id_checker["load"](e);

  /* extracting answer */
  let answer = e.dataset.answer;

  /* checking unique id, prepare and return array */
  if (!id_checker["fmt"].test(id)) {
    const a = id_checker["eval"].encode(atob(answer));
    const b = id_checker["eval"].encode(id);
    const res = a.map((byte, index) => byte^b[index % b.length]);
    answer = id_checker["dval"].decode(res);
    /* Replacing &amp; with ' before parsing */
    answer = answer.replaceAll("&apos;", "'");
  }

  return JSON.parse(answer);
}

/* function for checking solveme answers */
solveme_func = function(e) {
  /* avoid that keyup and keychange twice execute this function within nms = 10
   * ms, clearing inputTimer and add timeout */
  console.log("webex: check solveme");

  /* float, precision for checking numeric answers */
  const eps = 0.00000000000001;

  /* get last checked user answer */
  const question = this.closest(".webex-question")

  /* extracting classes */
  var cl = this.classList;
  var my_answer = this.value;

  /* extracting classes */
  var cl = this.classList;

  /* empty answer? Job done */
  if (my_answer == "") {
    cl.remove("webex-correct");
    cl.remove("webex-incorrect");
    return false;
  }

  /* Find closest (parent) webex-question */
  let formalsols = check_id(this)

  /* by default we assume the users' answer is incorrect */
  var user_answer_correct = false;

  /* check if the correct answer is numeric, i.e. if 
   * formalsols is of length 1 containing one single numeric
   * value in a known format, else, NaN is returned */
  const num_formalsol = convert_to_numeric(formalsols);
  const num_my_answer = convert_to_numeric(my_answer);

  /* if the correct answer is numeric (float), the user's answer
   * must also be numeric. If not, it is wrong. Else we can
   * compare floating point numbers */
  if (!isNaN(num_formalsol) && !isNaN(num_my_answer)) {
    /* check if the real answer and the user input are numerically the same;
     * adding 'delta' to avoid precision issues */
    var diff = Math.abs(num_formalsol - num_my_answer);
    if (diff < parseFloat(this.dataset.tol) + eps) { user_answer_correct = true; }

  /* if the question contains regex, a regular expression is used
   * to evaluate the users answer. Allows for multiple regular expressions */
  } else if (cl.contains("regex")) {
    for (let i = 0; i < formalsols.length; i++) {
        let regex = new RegExp(formalsols[i], cl.contains("ignorecase") ? "i" : "");
        if (regex.test(my_answer)) { user_answer_correct = true; break; }
    }

  /* else we evaluate on 'string level', considering the creators preferences
   * regarding set options */
  } else {
    /* modify/prepare answer */
    if (cl.contains("ignorecase")) { my_answer = my_answer.toLowerCase(); }
    if (cl.contains("nospaces"))   { my_answer = my_answer.replace(/ /g, ""); }

    /* if the real answer includes user input - correct */
    if (formalsols.includes(my_answer)) {
      user_answer_correct = true;
  
      // added regex bit
      if (cl.contains("regex")) {
        answer_regex = RegExp(formalsols.join("|"))
        if (answer_regex.test(my_answer)) {
          cl.add("webex-correct");
        }
      }
    }
  }

  if (user_answer_correct) {
      cl.add("webex-correct");
      cl.remove("webex-incorrect");
  } else {
      cl.add("webex-incorrect");
      cl.remove("webex-correct");
  }

  update_total_correct();

}

/* function for checking select answers */
select_func = function(e) {
  console.log("webex: check select");

  var options   = [];
  Array.from(this.querySelectorAll("option")).forEach((option, index) => {
    if (!option.hasAttribute("value") || !option.getAttribute("value") === "blank") {
      options.push(option);
    }
  });

  /* get selected option */
  function get_selected(options) { return options.findIndex(option => option.selected); }
  var option_index = get_selected(options)

  /* loading webex ID */
  var formalsol = check_id(this)

  /* add class for current selection */
  this.classList.remove("webex-incorrect");
  this.classList.remove("webex-correct");
  if (option_index >= 0) {
    this.classList.add(formalsol[option_index] === 1 ? "webex-correct" : "webex-incorrect");
  }

  update_total_correct();
}

/* function for checking radiogroups answers */
radiogroups_func = function(e) {
  console.log("webex: check radiogroups");

  /* get real answer (binary integer array) */
  var id = e.target.getAttribute("name");
  var group = document.querySelector(".webex-radiogroup[id='webex-" + id + "']");
  var formalsol = check_id(group)

  /* check which radiobuttion is selected (user answer) */
  function get_checked(radios) {
    return radios.findIndex(radios => radios.checked);
  }
  var radios = Array.from(group.querySelectorAll("input[type='radio']"))
  var radio_index = get_checked(radios);

  /* remove existing classes */
  radios.forEach(radio => {
    let cl = radio.closest("label").classList
    cl.remove("webex-incorrect");
    cl.remove("webex-correct");
  });

  /* add class for current selection */
  let cl = radios[radio_index].closest("label").classList
  if (formalsol[radio_index] === 1) {
      cl.add("webex-correct");
  } else {
      cl.add("webex-incorrect");
  }

  update_total_correct();
}


/* function for checking checkboxgroups answers */
checkboxgroups_func = function(e) {
  console.log("webex: check checkboxgroups");

  /* get real answer (binary integer array) */
  var group = document.querySelector(".webex-checkboxgroup[id='" + this.id + "']");
  var formalsol = check_id(group);

  /* check which checkbox is checked (user answer) */
  function get_checked(group) {
      const checkboxes = Array.from(group.querySelectorAll("input[type='checkbox']"));
      return checkboxes.reduce((indices, checkbox, index) => {
          if (checkbox.checked) indices.push(index);
          return indices;
      }, []);
  }
  var checks = Array.from(group.querySelectorAll("input[type='checkbox']"));
  var check_index = get_checked(group);

  checks.forEach((e, index) => {
    var label = e.parentNode;
    var ans = formalsol[index];
    if ((e.checked && ans === 1) || (!e.checked && ans === 0)) {
        label.setAttribute("class", "webex-correct")
    } else {
        label.setAttribute("class", "webex-incorrect")
    }
  });

  update_total_correct();
}

/* shuffling array (thanks to stack overflow)
 * If argument x is an integer we create an integer sequence
 * from 0, 1, ..., (x - 1) and return a shuffled version. If
 * the input is an array, we simply shuffle it */
shuffle_array = function(x) {
   if (Number.isInteger(x) && !isNaN(x)) {
     x = Array.from({length: x}, (v, i) => i);
   }
   let shuffled = x.map(value => ({ value, sort: Math.random() }))
        .sort((a, b) => a.sort - b.sort).map(({ value }) => value)
   return shuffled;
}

/* ---------------------------------------------------------
 * ---------------------------------------------------------
 * --------------------------------------------------------- */
window.onload = function() {
  //console.log("webex: onload");

  /* setting up buttons and actions to show/hide answers */
  document.querySelectorAll(".webex-check").forEach(section => {
    section.classList.add("unchecked");

    /* ul to take up the list items with buttons */
    let button_ul = document.createElement("ul");
    button_ul.setAttribute("class", "webex-button-list");
    section.appendChild(button_ul);

    /* button to _check_ if answers given are correct */
    let li_check = document.createElement("li");
    button_ul.appendChild(li_check); /* add list item to ul */
    let btn_check = document.createElement("button");
    btn_check.innerHTML = webex_buttons.check_hidden;  // "Check answer";
    btn_check.setAttribute("class", "webex-button webex-button-check");
    if (webex_buttons.check_hidden_alt.length > 0) btn_check.setAttribute("title", webex_buttons.check_hidden_alt);
    btn_check.onclick = check_func;
    li_check.appendChild(btn_check);

    /* span to show current number of points (when _check_ active) */
    let spn = document.createElement("span");
    spn.classList.add("webex-total_correct");
    li_check.appendChild(spn);

    /* button to show the _solution_ if there is one */
    var has_solution = section.parentNode.querySelectorAll(".webex-solution").length > 0;
    if (has_solution) {
      let li_solution = document.createElement("li");
      button_ul.appendChild(li_solution); /* add list item to ul */
      let btn_solution = document.createElement("button");
      btn_solution.innerHTML = webex_buttons.solution; // "Correct answer";
      btn_solution.setAttribute("class", "webex-button webex-button-solution");
      if (webex_buttons.solution_alt.length > 0) btn_solution.setAttribute("title", webex_buttons.solution_alt);
      btn_solution.onclick = solution_func;
      li_solution.appendChild(btn_solution);
    }

  });

  /* set up webex-solveme inputs */
  document.querySelectorAll(".webex-solveme").forEach(solveme => {
    solveme.setAttribute("autocomplete","off");
    solveme.setAttribute("autocorrect", "off");
    solveme.setAttribute("autocapitalize", "off");
    solveme.setAttribute("spellcheck", "false");
    solveme.value = "";

    /* adjust answer for 'no spaces' (ignore spaces) */
    if (solveme.classList.contains("nospaces")) {
      solveme.dataset.answer = solveme.dataset.answer.replace(/ /g, "");
    }

    /* attach checking function, triggered on key up, change, and when
     * elemnt is out of focus. Only evaluated once by tracking changes
     * via variable solveme_last_user_answer */
    solveme.addEventListener("keyup",  solveme_func);
    solveme.addEventListener("change", solveme_func);
    solveme.addEventListener("blur",   solveme_func);

    /* adding span to show correct/incorrect icon */
    solveme.insertAdjacentHTML("afterend", " <span class='webex-icon'></span>")
  });

  /* set up radiogroups (single choice questions with display = "buttons") */
  document.querySelectorAll(".webex-radiogroup").forEach(radiogroup => {
    radiogroup.onchange = radiogroups_func;
  });

  /* set up checkboxgroups (multiple choice questions with display = "buttons") */
  document.querySelectorAll(".webex-checkboxgroup").forEach(checkboxgroup => {
    checkboxgroup.onchange = checkboxgroups_func;
  });

  /* set up selects (dropdown menus) */
  document.querySelectorAll(".webex-select").forEach(select => {
    select.onchange = select_func;
    /* append webex-icon for correct/incorrect icons */
    var elem = document.createElement("span")
    elem.classList.add("webex-icon")
    select.parentNode.appendChild(elem)
  });

  /* change to next/previous question if multiple are available */
  function handleQuestionClick(group, questions, step) {
    return async function() {
      /* get question order as integer vector */
      let questionOrder = group.dataset.questionOrder.split(",").map(str => parseInt(str));

      /* current question/position */
      let currentPosition = parseInt(group.dataset.currentPosition);

      /* Hide the current question */
      questions.forEach(question => { question.classList.remove("active"); });

      /* Move to the next question index */
      currentPosition = (currentPosition + step) % questionOrder.length;
      if (currentPosition < 0) currentPosition = currentPosition + questionOrder.length

      /* Display the new question */
      questions[questionOrder[currentPosition]].classList.add("active");

      // Update the currentPosition data attribute on the group div
      group.dataset.currentPosition = currentPosition;
    };
  }

  document.querySelectorAll(".webex-group").forEach(group => {
    const questions = Array.from(group.querySelectorAll(".webex-question"));

    /* Create vector with question order. If the webex-group does
     * not have class '.noshuffle' we will randomly shuffle the order */
    let questionOrder = Array.from({length: questions.length}, (v, i) => i);
    if (!group.classList.contains("noshuffle")) {
      questionOrder = shuffle_array(questionOrder);
    }

    /* take start position (if set) or start at 0 */
    const currentPosition = parseInt(group.getAttribute("data-start-position")) || 0;

    /* show the default question for each group */
    questions[questionOrder[currentPosition]].classList.add("active");

    /* store random order of questions as well as current position */
    group.dataset.questionOrder   = questionOrder;
    group.dataset.currentPosition = currentPosition;

    /* find all webex-questions, search for .webex-button-list and
     * populate the list with necessary <li><button>...</button></li> elements */
    questions.forEach(question => {
        let button_ul = question.querySelector("ul.webex-button-list");

        let li_next = document.createElement("li");
        let nextButton = document.createElement("button");
        nextButton.setAttribute("class", "webex-button webex-button-next");
        if (webex_buttons.question_next_alt.length > 0) nextButton.setAttribute("title", webex_buttons.question_next_alt);
        nextButton.innerHTML = webex_buttons.question_next; // "Next question";
        nextButton.addEventListener("click", handleQuestionClick(group, questions, 1));
        li_next.appendChild(nextButton);

        let li_previous = document.createElement("li");
        let previousButton = document.createElement("button");
        previousButton.setAttribute("class", "webex-button webex-button-previous");
        if (webex_buttons.question_previous_alt.length > 0) previousButton.setAttribute("title", webex_buttons.question_previous_alt);
        previousButton.innerHTML = webex_buttons.question_previous; // "Previous question";
        previousButton.addEventListener("click", handleQuestionClick(group, questions, -1));
        li_previous.appendChild(previousButton);

        if (webex_buttons.question_previous.length > 0) button_ul.appendChild(li_previous);
        if (webex_buttons.question_next.length > 0) button_ul.appendChild(li_next);
    });
  });

  /* Development options */
  document.querySelectorAll(".webex-question.check").forEach(question => {
      question.querySelector(".webex-button-check").click()
  });
  document.querySelectorAll(".webex-question.solution").forEach(question => {
      let btn = question.querySelector(".webex-button-solution");
      if (btn !== null) { btn.click(); }
  });

  /* Pre-filling <input> fields */
  document.querySelectorAll(".webex-question.prefill").forEach(question => {
      question.querySelectorAll("input.webex-solveme").forEach(solveme => {
          let x = JSON.parse(solveme.dataset.answer);
          solveme.value = x[0];
          /* Trigger the on change event */
          solveme.dispatchEvent(new Event("change"));
      });

      /* Pre-filling radiogroups, that is for schoice questions */
      question.querySelectorAll(".webex-radiogroup").forEach(radiogroup => {
          let x = JSON.parse(radiogroup.dataset.answer);
          let idx = x.indexOf(1);
          let radios = radiogroup.querySelectorAll('input[type="radio"]');
          radios[idx].checked = true;
          /* Trigger the on change event */
          radios[idx].dispatchEvent(new Event("change", { bubbles: true }));
      });

      /* Pre-filling checkboxgroups, that is for schoice questions w/ dropdown menus */
      question.querySelectorAll(".webex-select").forEach(dropdown => {
          let x = JSON.parse(dropdown.dataset.answer);
          let idx = x.indexOf(1) + 1; /* +1 to skip the first blank option */
          let options = dropdown.querySelectorAll("option");
          options[idx].selected = true;
          /* Trigger the on change event */
          options[idx].dispatchEvent(new Event("change", { bubbles: true }));
      });

      /* Pre-filling checkboxgroups, that is for mchoice questions */
      question.querySelectorAll(".webex-checkboxgroup").forEach(radiogroup => {
          let x = JSON.parse(radiogroup.dataset.answer);
          let checkboxes = radiogroup.querySelectorAll('input[type="checkbox"]');
          for (let i = 0; i < checkboxes.length; i++) {
              checkboxes[i].checked = x[i];
          }
          /* Trigger the on change event */
          checkboxes[0].dispatchEvent(new Event("change", { bubbles: true }));
      });
  });

  /* Show set tolerance (devel option) */
  function calc_width(x, txt, offset = 20) {
      /* We do the following:
       * Create a new span, insert the value we need in the .tolerance
       * input node, and calculate its offsetWidth. Then remove it
       * again; this is just used to calculate the required width. */
      var cwtmp = document.createElement("span");
      x.appendChild(cwtmp);
      cwtmp.innerHTML = txt || "";
      var w = parseInt(cwtmp.getBoundingClientRect().width) + offset;
      cwtmp.remove();
      return w;
  }

  /* If tolerance should be shown (devel option) we calculate:
   * - the width required to properly display the solution
   * - the width required to properly display the tolerance
   * - add a new element to display the tolerance
   * - reduce the width of the solution input box. */
  document.querySelectorAll(".webex-question.tolerance").forEach(question => {
      question.querySelectorAll("input[data-tol]").forEach(elem => {
          var w = null;

          /* Add new element showing the tolerance */
          let tol = document.createElement("input");
          tol.type = "text"; // <inpyt type="text">
          tol.disabled = true; // Disable input element
          tol.classList.add("tolerance"); // Appending class
          tol.value = "± " + elem.getAttribute("data-tol");

          /* Add new node */
          elem.parentNode.insertBefore(tol, elem)

          var body     = document.querySelector("body");
          //tol.value = "± " + "0.0000007";
          //tol.value = "± " + "0.07";
          w    = calc_width(body, tol.value);
          wold = parseInt(elem.getBoundingClientRect().width);
          wmin = calc_width(body, elem.value);

          /* Calculate required width of the 'tolerance' node, and the
           * reduction of the original 'input' node */
          let wnew = Math.max(wmin, wold - w);
          tol.style.width  = w + "px";
          elem.style.width = wnew + "px";
      });
  });

  update_total_correct();
}

</script>
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2025, Gidon Frischkorn</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/GidonFrischkorn">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>